<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Road Rage - Survive Indian Roads!</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { overflow: hidden; background: #000; font-family: 'Trebuchet MS', 'Segoe UI', Arial, sans-serif; }

/* ===== MENU ===== */
#menu {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: linear-gradient(135deg, #FF6B35 0%, #F7931E 40%, #FFD166 100%);
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    z-index: 100; color: #fff; text-align: center;
}
#menu.hidden { display: none; }
#menu h1 {
    font-size: 5rem; font-weight: 900; letter-spacing: 4px;
    text-shadow: 4px 4px 0 #c0392b, 6px 6px 0 rgba(0,0,0,0.2);
    margin-bottom: 0.2rem;
}
#menu .tagline {
    font-size: 1.3rem; opacity: 0.9; margin-bottom: 2rem;
    font-style: italic; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}
.vehicle-select { display: flex; gap: 2rem; margin-bottom: 2rem; }
.vehicle-option {
    background: rgba(0,0,0,0.25); border-radius: 16px; padding: 1.5rem 2rem;
    cursor: pointer; transition: all 0.3s; border: 3px solid transparent;
    min-width: 180px;
}
.vehicle-option:hover { transform: translateY(-5px); border-color: #fff; background: rgba(0,0,0,0.4); }
.vehicle-emoji { font-size: 4rem; margin-bottom: 0.5rem; }
.vehicle-option h3 { font-size: 1.3rem; margin-bottom: 0.3rem; }
.vehicle-option p { font-size: 0.85rem; opacity: 0.8; }
.controls-info {
    background: rgba(0,0,0,0.2); border-radius: 10px; padding: 1rem 2rem;
    font-size: 0.95rem; opacity: 0.85;
}
.controls-info span { font-weight: bold; }

/* ===== HUD ===== */
#hud {
    position: fixed; top: 0; left: 0; width: 100%; padding: 1rem 1.5rem;
    display: flex; justify-content: space-between; align-items: flex-start;
    z-index: 50; pointer-events: none;
}
#hud.hidden { display: none; }
.hud-item {
    color: #fff; font-size: 1.2rem; font-weight: 700;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.7);
    background: rgba(0,0,0,0.3); padding: 0.4rem 0.8rem; border-radius: 8px;
}
#speed-display { font-size: 1.5rem; }
#distance-display { font-size: 1.1rem; }
#highscore-display { font-size: 0.9rem; opacity: 0.8; }

/* ===== GAME OVER ===== */
#gameover {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
    align-items: center; justify-content: center; z-index: 100; color: #fff;
    text-align: center;
}
#gameover.hidden { display: none; }
#gameover h2 {
    font-size: 4rem; color: #E53935; margin-bottom: 1rem;
    text-shadow: 3px 3px 0 rgba(0,0,0,0.5);
}
#gameover-reason {
    font-size: 1.6rem; margin-bottom: 0.5rem; color: #FFD166;
    max-width: 600px;
}
#gameover-message {
    font-size: 1.1rem; opacity: 0.7; margin-bottom: 1.5rem;
    font-style: italic;
}
#gameover-distance {
    font-size: 1.3rem; margin-bottom: 2rem;
}
#gameover-distance span { color: #4FC3F7; font-weight: bold; }
#gameover-highscore { font-size: 1rem; margin-bottom: 1.5rem; color: #FFD166; }
#restart-btn {
    background: #FF6B35; color: #fff; border: none; padding: 1rem 3rem;
    font-size: 1.3rem; font-weight: 700; border-radius: 12px; cursor: pointer;
    transition: all 0.2s; text-transform: uppercase; letter-spacing: 2px;
}
#restart-btn:hover { background: #E55A2B; transform: scale(1.05); }
#back-btn {
    background: transparent; color: #fff; border: 2px solid rgba(255,255,255,0.3);
    padding: 0.6rem 2rem; font-size: 1rem; border-radius: 8px; cursor: pointer;
    margin-top: 0.8rem; transition: all 0.2s;
}
#back-btn:hover { border-color: #fff; background: rgba(255,255,255,0.1); }

/* ===== WARNING FLASH ===== */
#warning {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    color: #FF5252; font-size: 2rem; font-weight: 900; z-index: 60;
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8); pointer-events: none;
    opacity: 0; transition: opacity 0.15s;
}
#warning.show { opacity: 1; }

/* ===== CANVAS ===== */
#game-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
canvas { display: block; }
</style>
</head>
<body>

<!-- Menu -->
<div id="menu">
    <h1>ROAD RAGE</h1>
    <p class="tagline">No lane discipline. No mercy. No helmet.</p>
    <div class="vehicle-select">
        <div class="vehicle-option" onclick="startGame('auto')">
            <div class="vehicle-emoji">üõ∫</div>
            <h3>Auto Rickshaw</h3>
            <p>The king of Indian roads.<br>Slow but steady.</p>
        </div>
        <div class="vehicle-option" onclick="startGame('scooty')">
            <div class="vehicle-emoji">üõµ</div>
            <h3>Scooty</h3>
            <p>Small, nimble, fragile.<br>Weave through chaos.</p>
        </div>
    </div>
    <div class="controls-info">
        <span>‚Üë/W</span> Accelerate &nbsp;|&nbsp;
        <span>‚Üì/S</span> Brake &nbsp;|&nbsp;
        <span>‚Üê/‚Üí</span> or <span>A/D</span> Change Lane &nbsp;|&nbsp;
        <span>SPACE</span> Honk!
    </div>
</div>

<!-- HUD -->
<div id="hud" class="hidden">
    <div>
        <div class="hud-item" id="speed-display">0 km/h</div>
        <div class="hud-item" id="highscore-display" style="margin-top:4px;"></div>
    </div>
    <div class="hud-item" id="distance-display">0 m</div>
</div>

<!-- Warning -->
<div id="warning"></div>

<!-- Game Over -->
<div id="gameover" class="hidden">
    <h2>GAME OVER</h2>
    <p id="gameover-reason"></p>
    <p id="gameover-message"></p>
    <p id="gameover-distance">You survived <span id="go-dist">0</span> meters</p>
    <p id="gameover-highscore"></p>
    <button id="restart-btn" onclick="restartGame()">TRY AGAIN</button>
    <button id="back-btn" onclick="backToMenu()">MAIN MENU</button>
</div>

<!-- Game Container -->
<div id="game-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================================
//  ROAD RAGE ‚Äî A 3D Indian Traffic Survival Game
// ============================================================================

// ===== CONSTANTS =====
const LANE_LEFT = -1.6;
const LANE_RIGHT = 1.6;
const ROAD_WIDTH = 8;
const ROAD_LENGTH = 500;
const FOG_NEAR = 60;
const FOG_FAR = 220;
const MIN_SPEED = 12;
const MAX_SPEED = 65;
const START_SPEED = 22;
const ACCEL = 12;
const BRAKE_DECEL = 25;
const NATURAL_DECEL = 2;
const LANE_SWITCH_SPEED = 10;
const SPAWN_AHEAD = 200;
const DESPAWN_BEHIND = 40;

// ===== MESSAGES =====
const POTHOLE_MSGS = [
    "That pothole has been there since 2019!",
    "PWD: Pothole Wala Department strikes again!",
    "Scientists discover new crater... on Indian roads!",
    "Your suspension: 'I resign.'",
    "That's not a pothole, that's a swimming pool!",
    "Nagar Nigam will fix it after monsoon... of 2035",
    "Achievement Unlocked: Found the Bermuda Triangle of roads",
    "Your tyre is now a modern art installation",
    "Fun fact: This pothole has its own Google Maps pin",
    "That pothole has survived 3 elections and 5 budgets"
];
const POLICE_MSGS = [
    "No PUC certificate! ‚Çπ10,000 challan!",
    "License expired 3 years ago, sir!",
    "Vehicle registered in different state ‚Äî SEIZED!",
    "Where is your helmet? ‚Çπ1,000 fine!",
    "Triple riding detected! ‚Çπ2,000 fine!",
    "No third-party insurance! ‚Çπ2,000 fine!",
    "Overspeeding! Speed limit is 30 km/h here!",
    "Sir, your vehicle fitness certificate expired!",
    "Number plate not as per HSRP norms!",
    "Challan: ‚Çπ5,000. Bribe offer: Declined.",
    "Your RC book? What RC book?",
    "Sir, this is a no-entry zone after 9 PM!",
    "Pollution Under Control? More like Pollution Under Carpet!",
    "No reflective tape on vehicle ‚Äî ‚Çπ500 fine!",
    "Sir, you have 47 pending e-challans!"
];
const TRAFFIC_MSGS = [
    "That truck didn't see you... or care!",
    "Horn OK Please, but you didn't please!",
    "The bus stops for no one. Especially not you.",
    "Another day, another insurance claim!",
    "You zigged when you should have zagged!",
    "Jugaad driving didn't work this time!",
    "The auto-wallah sends his regards.",
    "Signal? What signal? ‚Äî The other driver, probably",
    "Defensive driving? Never heard of her!",
    "That was a blind overtake. Emphasis on blind.",
    "India drives on the left. Mostly. Sometimes. Never."
];
const COW_MSGS = [
    "The cow is sacred. You are not.",
    "Cow 1, You 0",
    "Gau mata ki jai! Game over.",
    "Should've gone around like everyone else!",
    "Even Google Maps can't route around Indian cows",
    "The cow has right of way. Always. Forever.",
    "That cow pays no road tax and still owns the road",
    "Moo means 'get out of MY lane'"
];
const WRONGWAY_MSGS = [
    "Head-on collision! Should've honked louder!",
    "They were on the wrong side. Or were you?",
    "Indian roads: Where 'one-way' is just a suggestion!",
    "Wrong side? Both sides are wrong in India!",
    "That was a very confident wrong-side driver!"
];

// ===== GAME STATE =====
let state = 'menu';
let vehicleType = 'auto';
let playerMesh = null;
let playerZ = 0;
let playerSpeed = START_SPEED;
let playerLane = 0; // 0=left, 1=right
let distance = 0;
let highScore = parseInt(localStorage.getItem('roadrage_highscore') || '0');
let obstacles = [];
let nextSpawnZ = 60;
let honkCooldown = 0;
let honkTexts = [];
let roadElements = { markings: [], treesLeft: [], treesRight: [], edgesLeft: [], edgesRight: [] };
let difficultyTimer = 0;
let spawnCooldown = 0;
let lastVehicleType = 'auto';

// ===== INPUT =====
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });
window.addEventListener('blur', () => { Object.keys(keys).forEach(k => keys[k] = false); });

// ===== THREE.JS SETUP =====
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, FOG_NEAR, FOG_FAR);

const camera = new THREE.PerspectiveCamera(68, window.innerWidth / window.innerHeight, 0.1, 500);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.getElementById('game-container').appendChild(renderer.domElement);

// Lights
const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x8B7355, 0.6);
scene.add(hemiLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 15);
dirLight.castShadow = true;
dirLight.shadow.camera.left = -30;
dirLight.shadow.camera.right = 30;
dirLight.shadow.camera.top = 30;
dirLight.shadow.camera.bottom = -30;
dirLight.shadow.camera.far = 60;
dirLight.shadow.mapSize.width = 1024;
dirLight.shadow.mapSize.height = 1024;
scene.add(dirLight);
scene.add(dirLight.target);
const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
scene.add(ambientLight);

// ===== ROAD =====
// Main road surface
const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH);
const roadMat = new THREE.MeshLambertMaterial({ color: 0x3a3a3a });
const road = new THREE.Mesh(roadGeo, roadMat);
road.rotation.x = -Math.PI / 2;
road.receiveShadow = true;
scene.add(road);

// Road shoulders
const shoulderMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
const shoulderLeft = new THREE.Mesh(new THREE.PlaneGeometry(1, ROAD_LENGTH), shoulderMat);
shoulderLeft.rotation.x = -Math.PI / 2;
shoulderLeft.position.set(-ROAD_WIDTH / 2 - 0.5, 0.001, 0);
scene.add(shoulderLeft);
const shoulderRight = new THREE.Mesh(new THREE.PlaneGeometry(1, ROAD_LENGTH), shoulderMat);
shoulderRight.rotation.x = -Math.PI / 2;
shoulderRight.position.set(ROAD_WIDTH / 2 + 0.5, 0.001, 0);
scene.add(shoulderRight);

// Ground
const groundMat = new THREE.MeshLambertMaterial({ color: 0x8B9D5B });
const groundLeft = new THREE.Mesh(new THREE.PlaneGeometry(80, ROAD_LENGTH), groundMat);
groundLeft.rotation.x = -Math.PI / 2;
groundLeft.position.set(-45, -0.02, 0);
scene.add(groundLeft);
const groundRight = new THREE.Mesh(new THREE.PlaneGeometry(80, ROAD_LENGTH), groundMat);
groundRight.rotation.x = -Math.PI / 2;
groundRight.position.set(45, -0.02, 0);
scene.add(groundRight);

// Center lane markings (dashed)
const markMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
for (let i = 0; i < 60; i++) {
    const m = new THREE.Mesh(new THREE.PlaneGeometry(0.15, 2), markMat);
    m.rotation.x = -Math.PI / 2;
    m.position.y = 0.02;
    scene.add(m);
    roadElements.markings.push(m);
}

// Edge lines (solid)
const edgeMat = new THREE.MeshBasicMaterial({ color: 0xdddddd });
for (let i = 0; i < 30; i++) {
    const eL = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 8), edgeMat);
    eL.rotation.x = -Math.PI / 2;
    eL.position.set(-ROAD_WIDTH / 2 + 0.1, 0.02, 0);
    scene.add(eL);
    roadElements.edgesLeft.push(eL);
    const eR = new THREE.Mesh(new THREE.PlaneGeometry(0.12, 8), edgeMat);
    eR.rotation.x = -Math.PI / 2;
    eR.position.set(ROAD_WIDTH / 2 - 0.1, 0.02, 0);
    scene.add(eR);
    roadElements.edgesRight.push(eR);
}

// Trees
function makeTree() {
    const g = new THREE.Group();
    const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.12, 0.18, 1.5, 5),
        new THREE.MeshLambertMaterial({ color: 0x8B4513 })
    );
    trunk.position.y = 0.75;
    g.add(trunk);
    const leaves = new THREE.Mesh(
        new THREE.SphereGeometry(0.7 + Math.random() * 0.4, 6, 5),
        new THREE.MeshLambertMaterial({ color: 0x228B22 })
    );
    leaves.position.y = 1.8 + Math.random() * 0.3;
    g.add(leaves);
    return g;
}
for (let i = 0; i < 25; i++) {
    const tL = makeTree();
    tL.position.x = -ROAD_WIDTH / 2 - 2 - Math.random() * 4;
    scene.add(tL);
    roadElements.treesLeft.push(tL);
    const tR = makeTree();
    tR.position.x = ROAD_WIDTH / 2 + 2 + Math.random() * 4;
    scene.add(tR);
    roadElements.treesRight.push(tR);
}

// ===== VEHICLE CREATION FUNCTIONS =====
function createAutoRickshaw(color) {
    const g = new THREE.Group();
    const c = color || 0x2E7D32;
    const mat = new THREE.MeshPhongMaterial({ color: c });
    const yMat = new THREE.MeshPhongMaterial({ color: 0xFFD600 });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
    const glassMat = new THREE.MeshPhongMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.4 });

    // body
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.3, 1.0, 1.8), mat);
    body.position.set(0, 0.85, -0.1);
    body.castShadow = true;
    g.add(body);
    // roof
    const roof = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.08, 1.9), mat);
    roof.position.set(0, 1.4, -0.1);
    g.add(roof);
    // front
    const front = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.5), mat);
    front.position.set(0, 0.65, 0.85);
    g.add(front);
    // yellow stripe
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(1.32, 0.2, 1.82), yMat);
    stripe.position.set(0, 0.38, -0.1);
    g.add(stripe);
    // windshield
    const ws = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.4, 0.04), glassMat);
    ws.position.set(0, 1.05, 1.05);
    g.add(ws);
    // headlight
    const hl = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), yMat);
    hl.position.set(0, 0.6, 1.12);
    g.add(hl);
    // wheels
    const wGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.12, 8);
    [[0, 0.18, 0.8], [-0.65, 0.18, -0.6], [0.65, 0.18, -0.6]].forEach(p => {
        const w = new THREE.Mesh(wGeo, blackMat);
        w.rotation.z = Math.PI / 2;
        w.position.set(...p);
        g.add(w);
    });
    return g;
}

function createScooty(color) {
    const g = new THREE.Group();
    const c = color || 0x1565C0;
    const mat = new THREE.MeshPhongMaterial({ color: c });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
    const skinMat = new THREE.MeshPhongMaterial({ color: 0xD7A86E });

    // body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.4, 1.4), mat);
    body.position.set(0, 0.45, 0);
    body.castShadow = true;
    g.add(body);
    // seat
    const seat = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.08, 0.65), blackMat);
    seat.position.set(0, 0.7, -0.1);
    g.add(seat);
    // handlebar stem
    const stem = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.55, 0.08), new THREE.MeshPhongMaterial({ color: 0x666666 }));
    stem.position.set(0, 0.75, 0.6);
    g.add(stem);
    // handlebars
    const hb = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.06, 0.06), blackMat);
    hb.position.set(0, 1.05, 0.6);
    g.add(hb);
    // front wheel
    const wGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.1, 8);
    const fw = new THREE.Mesh(wGeo, blackMat);
    fw.rotation.z = Math.PI / 2;
    fw.position.set(0, 0.22, 0.6);
    g.add(fw);
    // rear wheel
    const rw = new THREE.Mesh(wGeo, blackMat);
    rw.rotation.z = Math.PI / 2;
    rw.position.set(0, 0.22, -0.55);
    g.add(rw);
    // rider torso
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.5, 0.25), new THREE.MeshPhongMaterial({ color: 0x5D4037 }));
    torso.position.set(0, 1.1, -0.05);
    g.add(torso);
    // rider head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.14, 8, 6), skinMat);
    head.position.set(0, 1.5, -0.05);
    g.add(head);
    // helmet
    const helmet = new THREE.Mesh(new THREE.SphereGeometry(0.16, 8, 6), new THREE.MeshPhongMaterial({ color: 0x333333 }));
    helmet.position.set(0, 1.55, -0.05);
    helmet.scale.set(1, 0.7, 1);
    g.add(helmet);
    return g;
}

function createTruck() {
    const g = new THREE.Group();
    const colors = [0xE53935, 0x1E88E5, 0x43A047, 0xFB8C00, 0x8E24AA, 0x00897B];
    const c = colors[Math.floor(Math.random() * colors.length)];
    const mat = new THREE.MeshPhongMaterial({ color: c });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

    // cabin
    const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.6, 1.6), mat);
    cabin.position.set(0, 1.3, 1.3);
    cabin.castShadow = true;
    g.add(cabin);
    // cargo
    const cargo = new THREE.Mesh(new THREE.BoxGeometry(2.0, 2.0, 3.5), mat);
    cargo.position.set(0, 1.5, -1.0);
    cargo.castShadow = true;
    g.add(cargo);
    // "HORN OK PLEASE" panel
    const panel = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.4, 0.04),
        new THREE.MeshPhongMaterial({ color: 0xFFEB3B }));
    panel.position.set(0, 0.7, -2.78);
    g.add(panel);
    // decorative dots on back
    [[-0.4, 1.0], [0, 1.0], [0.4, 1.0]].forEach(([x, y]) => {
        const dot = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 6),
            new THREE.MeshBasicMaterial({ color: 0xFF0000 }));
        dot.position.set(x, y, -2.78);
        g.add(dot);
    });
    // mudflaps
    const flapMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
    [-0.9, 0.9].forEach(x => {
        const flap = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.4, 0.04), flapMat);
        flap.position.set(x, 0.2, -2.75);
        g.add(flap);
    });
    // wheels
    const wGeo = new THREE.CylinderGeometry(0.28, 0.28, 0.18, 8);
    [-0.9, 0.9].forEach(x => {
        [0.8, -0.8, -1.8].forEach(z => {
            const w = new THREE.Mesh(wGeo, blackMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(x, 0.28, z);
            g.add(w);
        });
    });
    return g;
}

function createCar() {
    const g = new THREE.Group();
    const colors = [0xEEEEEE, 0x37474F, 0xC62828, 0x1565C0, 0x6A1B9A, 0x2E7D32, 0xF9A825, 0x4E342E];
    const c = colors[Math.floor(Math.random() * colors.length)];
    const mat = new THREE.MeshPhongMaterial({ color: c });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
    const glassMat = new THREE.MeshPhongMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.4 });

    // body
    const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.7, 3.2), mat);
    body.position.set(0, 0.6, 0);
    body.castShadow = true;
    g.add(body);
    // cabin
    const cab = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 1.6), mat);
    cab.position.set(0, 1.25, -0.2);
    g.add(cab);
    // windshield
    const ws = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 0.04), glassMat);
    ws.position.set(0, 1.2, 0.55);
    ws.rotation.x = 0.2;
    g.add(ws);
    // rear window
    const rw = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.4, 0.04), glassMat);
    rw.position.set(0, 1.2, -0.95);
    rw.rotation.x = -0.2;
    g.add(rw);
    // wheels
    const wGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.12, 8);
    [-0.75, 0.75].forEach(x => {
        [0.9, -0.9].forEach(z => {
            const w = new THREE.Mesh(wGeo, blackMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(x, 0.22, z);
            g.add(w);
        });
    });
    // headlights
    const hlMat = new THREE.MeshBasicMaterial({ color: 0xFFFFAA });
    [-0.5, 0.5].forEach(x => {
        const hl = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 6), hlMat);
        hl.position.set(x, 0.5, 1.62);
        g.add(hl);
    });
    return g;
}

function createBus() {
    const g = new THREE.Group();
    const colors = [0xD32F2F, 0x1976D2, 0xF57C00, 0x388E3C];
    const c = colors[Math.floor(Math.random() * colors.length)];
    const mat = new THREE.MeshPhongMaterial({ color: c });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
    const winMat = new THREE.MeshPhongMaterial({ color: 0x88CCFF, transparent: true, opacity: 0.35 });

    // body
    const body = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2.0, 5.5), mat);
    body.position.set(0, 1.5, 0);
    body.castShadow = true;
    g.add(body);
    // white stripe
    const stripe = new THREE.Mesh(new THREE.BoxGeometry(2.12, 0.25, 5.52),
        new THREE.MeshPhongMaterial({ color: 0xeeeeee }));
    stripe.position.set(0, 1.0, 0);
    g.add(stripe);
    // windows
    for (let i = -2; i <= 2; i++) {
        [-1.06, 1.06].forEach(x => {
            const win = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.6, 0.7), winMat);
            win.position.set(x, 1.8, i * 1.0);
            g.add(win);
        });
    }
    // wheels
    const wGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 8);
    [-1.0, 1.0].forEach(x => {
        [1.8, -1.8].forEach(z => {
            const w = new THREE.Mesh(wGeo, blackMat);
            w.rotation.z = Math.PI / 2;
            w.position.set(x, 0.3, z);
            g.add(w);
        });
    });
    return g;
}

function createCow() {
    const g = new THREE.Group();
    const bodyMat = new THREE.MeshPhongMaterial({ color: 0xF5F5DC });
    const brownMat = new THREE.MeshPhongMaterial({ color: 0x8D6E63 });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x111111 });

    // body
    const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 1.6), bodyMat);
    body.position.set(0, 0.9, 0);
    body.castShadow = true;
    g.add(body);
    // brown spots
    const spot = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.4), brownMat);
    spot.position.set(0.35, 1.05, 0.2);
    g.add(spot);
    const spot2 = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.35), brownMat);
    spot2.position.set(-0.3, 1.0, -0.3);
    g.add(spot2);
    // head
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), bodyMat);
    head.position.set(0, 1.1, 1.0);
    g.add(head);
    // horns
    [-0.2, 0.2].forEach(x => {
        const horn = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.04, 0.2, 5), new THREE.MeshPhongMaterial({ color: 0xBDBDBD }));
        horn.position.set(x, 1.45, 1.0);
        horn.rotation.z = x > 0 ? -0.3 : 0.3;
        g.add(horn);
    });
    // eyes
    [-0.12, 0.12].forEach(x => {
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.04, 6, 6), blackMat);
        eye.position.set(x, 1.2, 1.26);
        g.add(eye);
    });
    // legs
    [[-0.25, 0.5], [0.25, 0.5], [-0.25, -0.5], [0.25, -0.5]].forEach(([x, z]) => {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), bodyMat);
        leg.position.set(x, 0.25, z);
        g.add(leg);
    });
    // tail
    const tail = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.5), brownMat);
    tail.position.set(0, 0.95, -1.05);
    g.add(tail);
    return g;
}

function createPothole() {
    const g = new THREE.Group();
    // dark crater
    const crater = new THREE.Mesh(
        new THREE.CircleGeometry(0.7, 12),
        new THREE.MeshLambertMaterial({ color: 0x0a0a0a })
    );
    crater.rotation.x = -Math.PI / 2;
    crater.position.y = 0.015;
    g.add(crater);
    // cracked edge
    const edge = new THREE.Mesh(
        new THREE.RingGeometry(0.6, 0.9, 12),
        new THREE.MeshLambertMaterial({ color: 0x1a1a1a })
    );
    edge.rotation.x = -Math.PI / 2;
    edge.position.y = 0.012;
    g.add(edge);
    // rubble bits
    for (let i = 0; i < 5; i++) {
        const bit = new THREE.Mesh(
            new THREE.BoxGeometry(0.08, 0.04, 0.08),
            new THREE.MeshLambertMaterial({ color: 0x333333 })
        );
        const angle = Math.random() * Math.PI * 2;
        const dist = 0.3 + Math.random() * 0.3;
        bit.position.set(Math.cos(angle) * dist, 0.02, Math.sin(angle) * dist);
        bit.rotation.y = Math.random() * Math.PI;
        g.add(bit);
    }
    return g;
}

function createPolice() {
    const g = new THREE.Group();
    const khakiMat = new THREE.MeshPhongMaterial({ color: 0xC3A86B });
    const skinMat = new THREE.MeshPhongMaterial({ color: 0xD2A06C });
    const blackMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
    const redMat = new THREE.MeshPhongMaterial({ color: 0xFF0000 });
    const whiteMat = new THREE.MeshPhongMaterial({ color: 0xFFFFFF });

    // legs
    [-0.1, 0.1].forEach(x => {
        const leg = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.8, 0.18), khakiMat);
        leg.position.set(x, 0.4, 0);
        g.add(leg);
    });
    // body
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.7, 0.25), khakiMat);
    torso.position.set(0, 1.15, 0);
    torso.castShadow = true;
    g.add(torso);
    // belt
    const belt = new THREE.Mesh(new THREE.BoxGeometry(0.47, 0.08, 0.27), new THREE.MeshPhongMaterial({ color: 0x5D4037 }));
    belt.position.set(0, 0.85, 0);
    g.add(belt);
    // head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.16, 8, 6), skinMat);
    head.position.set(0, 1.7, 0);
    g.add(head);
    // hat
    const hat = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.18, 0.12, 8), khakiMat);
    hat.position.set(0, 1.92, 0);
    g.add(hat);
    const hatBrim = new THREE.Mesh(new THREE.CylinderGeometry(0.24, 0.24, 0.03, 8), khakiMat);
    hatBrim.position.set(0, 1.87, 0);
    g.add(hatBrim);
    // outstretched arm
    const arm = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.12, 0.12), khakiMat);
    arm.position.set(0.5, 1.3, 0);
    g.add(arm);
    // stop sign (hand)
    const sign = new THREE.Mesh(new THREE.CircleGeometry(0.14, 8), redMat);
    sign.position.set(0.82, 1.3, 0.01);
    g.add(sign);
    // STOP text (white dot on sign)
    const stopDot = new THREE.Mesh(new THREE.CircleGeometry(0.06, 6), whiteMat);
    stopDot.position.set(0.82, 1.3, 0.02);
    g.add(stopDot);
    // traffic cone beside
    const cone = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.5, 6), new THREE.MeshPhongMaterial({ color: 0xFF6D00 }));
    cone.position.set(-0.5, 0.25, 0.3);
    g.add(cone);
    const coneStripe = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.14, 0.08, 6), whiteMat);
    coneStripe.position.set(-0.5, 0.3, 0.3);
    g.add(coneStripe);

    return g;
}

// ===== HITBOX CONFIGS =====
const HITBOXES = {
    auto:      { width: 1.3, length: 2.0 },
    scooty:    { width: 0.5, length: 1.4 },
    truck:     { width: 2.0, length: 5.5 },
    car:       { width: 1.6, length: 3.2 },
    bus:       { width: 2.1, length: 5.5 },
    cow:       { width: 1.0, length: 1.8 },
    pothole:   { width: 1.2, length: 1.2 },
    police:    { width: 1.2, length: 0.8 },
    wrongway:  { width: 1.6, length: 3.2 }
};

// ===== OBSTACLE SPAWNING =====
function laneX(lane) { return lane === 0 ? LANE_LEFT : LANE_RIGHT; }

function spawnObstacle(type, lane, z, subtype) {
    let mesh;
    let hitbox;
    let speed = 0;
    let canChangeLane = false;

    switch (type) {
        case 'pothole':
            mesh = createPothole();
            hitbox = HITBOXES.pothole;
            break;
        case 'cow':
            mesh = createCow();
            hitbox = HITBOXES.cow;
            // cows sometimes face sideways
            if (Math.random() < 0.5) mesh.rotation.y = Math.PI / 2 * (Math.random() < 0.5 ? 1 : -1);
            break;
        case 'police':
            mesh = createPolice();
            hitbox = HITBOXES.police;
            mesh.rotation.y = Math.PI; // face the player
            break;
        case 'truck':
            mesh = createTruck();
            hitbox = HITBOXES.truck;
            speed = 8 + Math.random() * 10;
            canChangeLane = Math.random() < 0.3;
            break;
        case 'car':
            mesh = createCar();
            hitbox = HITBOXES.car;
            speed = 10 + Math.random() * 12;
            canChangeLane = Math.random() < 0.4;
            break;
        case 'bus':
            mesh = createBus();
            hitbox = HITBOXES.bus;
            speed = 7 + Math.random() * 8;
            canChangeLane = Math.random() < 0.15;
            break;
        case 'auto':
            mesh = createAutoRickshaw(0x4CAF50);
            hitbox = HITBOXES.auto;
            speed = 9 + Math.random() * 8;
            canChangeLane = Math.random() < 0.5;
            break;
        case 'wrongway':
            mesh = Math.random() < 0.5 ? createCar() : createTruck();
            hitbox = Math.random() < 0.5 ? HITBOXES.car : HITBOXES.truck;
            mesh.rotation.y = Math.PI;
            speed = -(25 + Math.random() * 15);
            break;
    }

    mesh.position.set(laneX(lane), 0, z);
    scene.add(mesh);

    obstacles.push({
        type, mesh, hitbox, speed,
        lane, targetLane: lane,
        canChangeLane,
        laneChangeTimer: 2 + Math.random() * 4,
        speedChangeTimer: 3 + Math.random() * 5,
        erratic: Math.random() < 0.3
    });
}

function getSpawnGap() {
    const diff = 1 + distance / 800;
    return Math.max(10, 30 / diff) + Math.random() * Math.max(5, 15 / diff);
}

function manageSpawning() {
    while (nextSpawnZ < playerZ + SPAWN_AHEAD) {
        const rand = Math.random();
        const lane = Math.random() < 0.5 ? 0 : 1;
        const diff = Math.min(distance / 1000, 1);

        if (rand < 0.22) {
            spawnObstacle('pothole', lane, nextSpawnZ);
        } else if (rand < 0.35) {
            spawnObstacle('truck', lane, nextSpawnZ);
        } else if (rand < 0.48) {
            spawnObstacle('car', lane, nextSpawnZ);
        } else if (rand < 0.56) {
            spawnObstacle('bus', lane, nextSpawnZ);
        } else if (rand < 0.64) {
            spawnObstacle('auto', lane, nextSpawnZ);
        } else if (rand < 0.74) {
            spawnObstacle('cow', lane, nextSpawnZ);
        } else if (rand < 0.74 + 0.12 * diff && distance > 150) {
            spawnObstacle('police', lane, nextSpawnZ);
        } else if (rand < 0.74 + 0.12 * diff + 0.06 * diff && distance > 400) {
            spawnObstacle('wrongway', lane, nextSpawnZ);
        }
        // else: empty gap (breathing room)

        nextSpawnZ += getSpawnGap();
    }
}

// ===== UPDATE OBSTACLES =====
function updateObstacles(delta) {
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const o = obstacles[i];

        // Move
        if (o.speed !== 0) {
            o.mesh.position.z += o.speed * delta;
        }

        // Traffic AI
        if (o.canChangeLane) {
            o.laneChangeTimer -= delta;
            if (o.laneChangeTimer <= 0) {
                if (o.erratic || Math.random() < 0.4) {
                    o.targetLane = o.targetLane === 0 ? 1 : 0;
                }
                o.laneChangeTimer = (o.erratic ? 1.5 : 3) + Math.random() * 3;
            }
        }

        // Speed variation for traffic
        if (o.speed > 0) {
            o.speedChangeTimer -= delta;
            if (o.speedChangeTimer <= 0) {
                if (o.erratic) {
                    o.speed = Math.max(3, o.speed + (Math.random() - 0.6) * 10);
                } else {
                    o.speed = Math.max(5, o.speed + (Math.random() - 0.5) * 5);
                }
                o.speedChangeTimer = 2 + Math.random() * 4;
            }
        }

        // Smooth lane transition
        const targetX = laneX(o.targetLane);
        o.mesh.position.x += (targetX - o.mesh.position.x) * 3 * delta;
        o.lane = Math.abs(o.mesh.position.x - LANE_LEFT) < Math.abs(o.mesh.position.x - LANE_RIGHT) ? 0 : 1;

        // Tilt during lane change
        const xDiff = targetX - o.mesh.position.x;
        if (Math.abs(xDiff) > 0.1 && o.speed > 0) {
            o.mesh.rotation.z = -xDiff * 0.05;
        } else {
            o.mesh.rotation.z *= 0.9;
        }

        // Despawn
        if (o.mesh.position.z < playerZ - DESPAWN_BEHIND ||
            (o.speed < 0 && o.mesh.position.z < playerZ - 50)) {
            scene.remove(o.mesh);
            obstacles.splice(i, 1);
        }
    }
}

// ===== COLLISION DETECTION =====
function checkCollisions() {
    if (!playerMesh) return null;
    const px = playerMesh.position.x;
    const pz = playerMesh.position.z;
    const phb = HITBOXES[vehicleType];

    for (const o of obstacles) {
        const ox = o.mesh.position.x;
        const oz = o.mesh.position.z;
        const ohb = o.hitbox;

        // Shrink hitboxes slightly for fairness
        const fair = 0.85;
        if (Math.abs(px - ox) < (phb.width + ohb.width) * 0.5 * fair &&
            Math.abs(pz - oz) < (phb.length + ohb.length) * 0.5 * fair) {
            return o;
        }
    }
    return null;
}

// ===== HONK SYSTEM =====
function doHonk() {
    if (honkCooldown > 0) return;
    honkCooldown = 0.5;

    // Show HONK text
    const warning = document.getElementById('warning');
    warning.textContent = ['HONK!', 'BEEP BEEP!', 'PEE PEE PEE!', 'HORN OK!'][Math.floor(Math.random() * 4)];
    warning.classList.add('show');
    setTimeout(() => warning.classList.remove('show'), 300);

    // Make nearby vehicles swerve
    for (const o of obstacles) {
        if (o.speed > 0 && o.canChangeLane) {
            const dist = o.mesh.position.z - playerZ;
            if (dist > 0 && dist < 25) {
                // Vehicle ahead might move over
                if (Math.random() < 0.35) {
                    o.targetLane = o.targetLane === 0 ? 1 : 0;
                    o.laneChangeTimer = 2;
                }
            }
        }
    }
}

// ===== ROAD ELEMENTS UPDATE =====
function updateRoadElements() {
    // Center markings
    const mSpacing = 4;
    const mBase = Math.floor(playerZ / mSpacing) * mSpacing - 30;
    roadElements.markings.forEach((m, i) => { m.position.z = mBase + i * mSpacing; });

    // Edge lines
    const eSpacing = 8;
    const eBase = Math.floor(playerZ / eSpacing) * eSpacing - 30;
    roadElements.edgesLeft.forEach((e, i) => { e.position.z = eBase + i * eSpacing; });
    roadElements.edgesRight.forEach((e, i) => { e.position.z = eBase + i * eSpacing; });

    // Trees
    const tSpacing = 18;
    const tBase = Math.floor(playerZ / tSpacing) * tSpacing - 50;
    roadElements.treesLeft.forEach((t, i) => { t.position.z = tBase + i * tSpacing; });
    roadElements.treesRight.forEach((t, i) => { t.position.z = tBase + i * tSpacing + tSpacing / 2; });

    // Road and ground follow player
    road.position.z = playerZ;
    shoulderLeft.position.z = playerZ;
    shoulderRight.position.z = playerZ;
    groundLeft.position.z = playerZ;
    groundRight.position.z = playerZ;
}

// ===== GAME LOGIC =====
function startGame(type) {
    vehicleType = type;
    lastVehicleType = type;
    state = 'playing';

    // Reset state
    playerZ = 0;
    playerSpeed = START_SPEED;
    playerLane = 0;
    distance = 0;
    nextSpawnZ = 50;
    obstacles.forEach(o => scene.remove(o.mesh));
    obstacles.length = 0;

    // Create player vehicle
    if (playerMesh) scene.remove(playerMesh);
    playerMesh = type === 'auto' ? createAutoRickshaw(0x2E7D32) : createScooty(0x1565C0);
    playerMesh.position.set(LANE_LEFT, 0, 0);
    scene.add(playerMesh);

    // UI
    document.getElementById('menu').classList.add('hidden');
    document.getElementById('gameover').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    updateHighScoreDisplay();
}

function restartGame() {
    startGame(lastVehicleType);
}

function backToMenu() {
    state = 'menu';
    if (playerMesh) { scene.remove(playerMesh); playerMesh = null; }
    obstacles.forEach(o => scene.remove(o.mesh));
    obstacles.length = 0;
    document.getElementById('gameover').classList.add('hidden');
    document.getElementById('hud').classList.add('hidden');
    document.getElementById('menu').classList.remove('hidden');
    nextSpawnZ = 50;
    createMenuTraffic();
}

function triggerGameOver(obstacle) {
    state = 'gameover';
    let msgs, reason;

    switch (obstacle.type) {
        case 'pothole':
            msgs = POTHOLE_MSGS;
            reason = "You hit a pothole!";
            break;
        case 'police':
            msgs = POLICE_MSGS;
            reason = "Caught by Traffic Police!";
            break;
        case 'cow':
            msgs = COW_MSGS;
            reason = "You hit a cow!";
            break;
        case 'wrongway':
            msgs = WRONGWAY_MSGS;
            reason = "Head-on collision!";
            break;
        default:
            msgs = TRAFFIC_MSGS;
            reason = "Traffic collision!";
    }

    const msg = msgs[Math.floor(Math.random() * msgs.length)];
    const dist = Math.floor(distance);

    // Update high score
    if (dist > highScore) {
        highScore = dist;
        localStorage.setItem('roadrage_highscore', highScore.toString());
    }

    document.getElementById('gameover-reason').textContent = msg;
    document.getElementById('gameover-message').textContent = reason;
    document.getElementById('go-dist').textContent = dist >= 1000 ? (dist / 1000).toFixed(1) + ' km' : dist + ' m';
    document.getElementById('gameover-highscore').textContent = 'Best: ' + (highScore >= 1000 ? (highScore / 1000).toFixed(1) + ' km' : highScore + ' m');
    document.getElementById('gameover').classList.remove('hidden');
    document.getElementById('hud').classList.add('hidden');
}

function updateHighScoreDisplay() {
    const el = document.getElementById('highscore-display');
    if (highScore > 0) {
        el.textContent = 'Best: ' + (highScore >= 1000 ? (highScore / 1000).toFixed(1) + ' km' : highScore + ' m');
    } else {
        el.textContent = '';
    }
}

// ===== MAIN UPDATE =====
function update(delta) {
    // Clamp delta to avoid physics issues on tab switch
    delta = Math.min(delta, 0.05);

    // Input
    const accel = keys['ArrowUp'] || keys['KeyW'];
    const brake = keys['ArrowDown'] || keys['KeyS'];
    const goLeft = keys['ArrowLeft'] || keys['KeyA'];
    const goRight = keys['ArrowRight'] || keys['KeyD'];
    const honk = keys['Space'];

    // Speed
    if (accel) {
        playerSpeed = Math.min(MAX_SPEED, playerSpeed + ACCEL * delta);
    } else if (brake) {
        playerSpeed = Math.max(MIN_SPEED * 0.5, playerSpeed - BRAKE_DECEL * delta);
    } else {
        // Gradually settle to a cruising speed
        const cruise = MIN_SPEED + (MAX_SPEED - MIN_SPEED) * 0.3;
        if (playerSpeed > cruise) {
            playerSpeed -= NATURAL_DECEL * delta;
        } else if (playerSpeed < MIN_SPEED) {
            playerSpeed += ACCEL * 0.5 * delta;
        }
    }

    // Move forward
    const dz = playerSpeed * delta;
    playerZ += dz;
    distance += dz;

    // Lane switching
    if (goLeft) playerLane = 0;
    if (goRight) playerLane = 1;
    const targetX = laneX(playerLane);
    const prevX = playerMesh.position.x;
    playerMesh.position.x += (targetX - playerMesh.position.x) * LANE_SWITCH_SPEED * delta;
    playerMesh.position.z = playerZ;

    // Vehicle tilt on lane change
    const laneDelta = playerMesh.position.x - prevX;
    playerMesh.rotation.z = -laneDelta * 2;

    // Slight bounce
    playerMesh.position.y = Math.sin(playerZ * 1.2) * 0.015;

    // Honk
    if (honk) doHonk();
    honkCooldown = Math.max(0, honkCooldown - delta);

    // Spawn & update obstacles
    manageSpawning();
    updateObstacles(delta);

    // Collision
    const hit = checkCollisions();
    if (hit) {
        triggerGameOver(hit);
        return;
    }

    // Update road
    updateRoadElements();

    // Camera
    const camTargetX = playerMesh.position.x * 0.4;
    camera.position.x += (camTargetX - camera.position.x) * 4 * delta;
    camera.position.y = 4.5;
    camera.position.z = playerZ - 8;
    camera.lookAt(playerMesh.position.x * 0.6, 0.8, playerZ + 18);

    // Dynamic FOV
    const speedRatio = playerSpeed / MAX_SPEED;
    const targetFov = 65 + speedRatio * 18;
    camera.fov += (targetFov - camera.fov) * 3 * delta;
    camera.updateProjectionMatrix();

    // Move directional light with player
    dirLight.position.set(playerMesh.position.x + 10, 20, playerZ + 15);
    dirLight.target.position.set(playerMesh.position.x, 0, playerZ);
    dirLight.target.updateMatrixWorld();

    // HUD
    const displaySpeed = Math.floor(playerSpeed * 3.6);
    document.getElementById('speed-display').textContent = displaySpeed + ' km/h';
    const d = Math.floor(distance);
    document.getElementById('distance-display').textContent = d >= 1000 ? (d / 1000).toFixed(1) + ' km' : d + ' m';
}

// ===== ANIMATION LOOP =====
const clock = new THREE.Clock();
function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();

    if (state === 'playing') {
        update(delta);
    } else if (state === 'menu') {
        // Slow camera orbit for menu background
        const t = clock.elapsedTime;
        camera.position.set(Math.sin(t * 0.15) * 4, 5.5, Math.cos(t * 0.15) * 4 - 3);
        camera.lookAt(0, 0.5, 10);
        // Animate menu traffic slowly
        obstacles.forEach(o => {
            if (o.speed > 0) o.mesh.position.z += o.speed * delta * 0.4;
        });
    }

    renderer.render(scene, camera);
}

// ===== WINDOW RESIZE =====
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// ===== INIT =====
// Position camera for menu
camera.position.set(0, 5, -5);
camera.lookAt(0, 0.5, 8);

// Add some traffic for menu background
function createMenuTraffic() {
    const types = ['truck', 'car', 'bus', 'auto', 'cow'];
    for (let i = 0; i < 8; i++) {
        const type = types[Math.floor(Math.random() * types.length)];
        const lane = Math.random() < 0.5 ? 0 : 1;
        const z = 10 + i * 20 + Math.random() * 10;
        spawnObstacle(type, lane, z);
    }
    // Add some potholes
    for (let i = 0; i < 3; i++) {
        spawnObstacle('pothole', Math.random() < 0.5 ? 0 : 1, 15 + i * 30);
    }
}
createMenuTraffic();

// Start animation
animate();

// Expose functions to HTML onclick
window.startGame = startGame;
window.restartGame = restartGame;
window.backToMenu = backToMenu;
</script>
</body>
</html>
